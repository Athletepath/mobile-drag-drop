{"version":3,"sources":["/Users/stefansteinhart/Development/Web/ios-html5-drag-drop-shim/src/scroll-behaviour.ts"],"names":["isTopLevelEl","el","document","body","documentElement","getElementViewportOffset","axis","offset","clientLeft","clientTop","bounds","getBoundingClientRect","left","top","getElementViewportSize","window","innerWidth","innerHeight","clientWidth","clientHeight","getSetElementScroll","scroll","prop","isTopLevel","arguments","length","isScrollable","cs","getComputedStyle","scrollHeight","overflowY","scrollWidth","overflowX","findScrollableParent","parentNode","determineScrollIntention","currentCoordinate","size","threshold","determineDynamicVelocity","scrollIntention","Math","abs","isScrollEndReached","scrollBounds","currentScrollOffset","width","height","scheduleScrollAnimation","_scrollAnimationFrameId","requestAnimationFrame","scrollAnimation","scrollDiffX","scrollDiffY","_scrollableParent","_scrollIntentions","horizontal","round","_options","velocityFn","_dynamicVelocity","x","vertical","y","_translateDragImageFn","updateScrollIntentions","_currentCoordinates","currentCoordinates","scrollableParent","scrollIntentions","dynamicVelocity","scrollableParentBounds","scrollX","scrollY","currentCoordinatesOffset","_hoveredElement","velocity","multiplier","event","hoveredElement","translateDragImageFn","cancelAnimationFrame"],"mappings":"iMA+BA,SAAAA,EAAsBC,GAElB,OAAQA,IAAOC,SAASC,MAAQF,IAAOC,SAASE,gBAGpD,SAAAC,EAAkCJ,EAAgBK,GAC9C,IAAIC,EAEJ,GAAIP,EAAaC,GACbM,EAAc,IAAJD,EAAkCL,EAAGO,WAAaP,EAAGQ,cAE9D,CACD,IAAMC,EAAST,EAAGU,wBAClBJ,EAAc,IAAJD,EAAkCI,EAAOE,KAAOF,EAAOG,IAGrE,OAAON,EAGX,SAAAO,EAAgCb,EAAgBK,GAU5C,OAPIN,EAAaC,GACD,IAAJK,EAAkCS,OAAOC,WAAaD,OAAOE,YAGzD,IAAJX,EAAkCL,EAAGiB,YAAcjB,EAAGkB,aAMtE,SAAAC,EAA6BnB,EAAgBK,EAAiBe,GAC1D,IAAMC,EAAY,IAAJhB,EAAkC,aAAe,YAGzDiB,EAAavB,EAAaC,GAEhC,GAAyB,IAArBuB,UAAUC,OAEV,OAAIF,EACOrB,SAASC,KAAKmB,IAASpB,SAASE,gBAAgBkB,GAGpDrB,EAAGqB,GAGVC,GACArB,SAASE,gBAAgBkB,IAASD,EAClCnB,SAASC,KAAKmB,IAASD,GAGvBpB,EAAGqB,IAASD,EAKpB,SAAAK,EAAsBzB,GAClB,IAAM0B,EAAKC,iBAAiB3B,GAE5B,OAAIA,EAAG4B,aAAe5B,EAAGkB,eAAkC,WAAjBQ,EAAGG,WAA2C,SAAjBH,EAAGG,YAItE7B,EAAG8B,YAAc9B,EAAGiB,cAAiC,WAAjBS,EAAGK,WAA2C,SAAjBL,EAAGK,WAO5E,SAAAC,EAA8BhC,GAC1B,EAAG,CACC,IAAKA,EACD,OAEJ,GAAIyB,EAAazB,GACb,OAAOA,EAEX,GAAIA,IAAOC,SAASE,gBAChB,OAAO,WAENH,EAAkBA,EAAGiC,YAC9B,OAAO,KAGX,SAAAC,EAAkCC,EAA0BC,EAAaC,GAGrE,OAAIF,EAAoBE,GACpB,EAGKD,EAAOD,EAAoBE,EAChC,EAGJ,EAGJ,SAAAC,EAAkCC,EAAiCJ,EAA0BC,EAAaC,GAEtG,OAAmB,IAAfE,EAEOC,KAAKC,IAAIN,EAAoBE,GAEhB,IAAfE,EAEEC,KAAKC,IAAIL,EAAOD,EAAoBE,GAGxC,EAGX,SAAAK,EAA4BrC,EAAiBkC,EAAiCI,GAE1E,IAAMC,EAA2B,IAAJvC,EAAmCsC,EAAoB,QAAKA,EAAoB,QAG7G,OAAmB,IAAfJ,EAMOK,IAJsB,IAAJvC,EAAmCsC,EAAab,YAAca,EAAaE,MAAUF,EAAaf,aACvHe,EAAaG,SAMG,IAAfP,GAGGK,GAAuB,EAuEvC,SAAAG,IAGUC,IAKNA,EAA0BlC,OAAOmC,sBAAsBC,IAG3D,SAAAA,IAEI,IAAIC,EAAc,EACdC,EAAc,EACd9B,EAAavB,EAAasD,GAEE,IAA5BC,EAAkBC,aAElBJ,EAAcX,KAAKgB,MAAMC,EAASC,WAAWC,EAAiBC,EAAGH,EAASpB,WAAaiB,EAAkBC,YACzGpC,EAAoBkC,EAAiB,EAAyBF,IAGpC,IAA1BG,EAAkBO,WAElBT,EAAcZ,KAAKgB,MAAMC,EAASC,WAAWC,EAAiBG,EAAGL,EAASpB,WAAaiB,EAAkBO,UACzG1C,EAAoBkC,EAAiB,EAAuBD,IAG5D9B,EAEAyC,EAAsBZ,EAAaC,GAInCW,EAAsB,EAAG,GAI7Bf,EAA0B,KAItBgB,EAAuBC,EAAqBZ,EAAmBI,EAASpB,UAAWiB,EAAmBK,IAGtGZ,IAQR,SAAAiB,EAAgCE,EACAC,EACA9B,EACA+B,EACAC,GAE5B,IAAKH,IAAuBC,EAGxB,OAAO,EAGX,IAAMG,GACFV,EAAGxD,EAAyB+D,EAAgB,GAC5CL,EAAG1D,EAAyB+D,EAAgB,GAC5CtB,MAAOhC,EAAuBsD,EAAgB,GAC9CrB,OAAQjC,EAAuBsD,EAAgB,GAC/CI,QAASpD,EAAoBgD,EAAgB,GAC7CK,QAASrD,EAAoBgD,EAAgB,GAC7CrC,YAAaqC,EAAiBrC,YAC9BF,aAAcuC,EAAiBvC,cAG7B6C,GACFb,EAAGM,EAAmBN,EAAIU,EAAuBV,EACjDE,EAAGI,EAAmBJ,EAAIQ,EAAuBR,GA0BrD,OAvBAM,EAAiBb,WAAarB,EAAyBuC,EAAyBb,EAAGU,EAAuBzB,MAAOR,GACjH+B,EAAiBP,SAAW3B,EAAyBuC,EAAyBX,EAAGQ,EAAuBxB,OAAQT,GAE5G+B,EAAiBb,YAAcb,EAAkB,EAAwB0B,EAAiBb,WAAYe,GAGtGF,EAAiBb,WAAU,EAEtBa,EAAiBb,aAEtBc,EAAgBT,EAAItB,EAAyB8B,EAAiBb,WAAYkB,EAAyBb,EAAGU,EAAuBzB,MAAOR,IAGpI+B,EAAiBP,UAAYnB,EAAkB,EAAsB0B,EAAiBP,SAAUS,GAGhGF,EAAiBP,SAAQ,EAEpBO,EAAiBP,WAEtBQ,EAAgBP,EAAIxB,EAAyB8B,EAAiBP,SAAUY,EAAyBX,EAAGQ,EAAuBxB,OAAQT,OAG7H+B,EAAiBb,aAAca,EAAiBP,UAxK9D,IAoBIb,EACAiB,EACAS,EACArB,EACAU,EAxBAN,GACApB,UAAW,GAEXqB,WAAY,SAAUiB,EAAiBtC,GACnC,IAAMuC,EAAaD,EAAWtC,EAE9B,OADoBuC,EAAaA,EAAaA,EACzBvC,IAIzBiB,GACAC,WAAU,EACVM,SAAQ,GAGRF,GACAC,EAAG,EACHE,EAAG,+CAYP,SAA0Ce,EACAX,EACAY,EACAC,GAEtCd,EAAsBC,EACtBH,EAAwBgB,EAGpBL,IAAoBI,IAGpBzB,EAAoBrB,EADpB0C,EAAkBI,IAMSd,EAAuBC,EAAqBZ,EAAmBI,EAASpB,UAAWiB,EAAmBK,GAMjIZ,IAEOC,IAEPlC,OAAOkE,qBAAqBhC,GAC5BA,EAA0B","file":"scroll-behaviour.min.js","sourcesContent":["//<editor-fold desc=\"static scroll utils\">\n\nimport { DragImageTranslateOverrideFn, Point } from \"./index\";\n\ninterface ScrollIntentions {\n    horizontal:ScrollIntention;\n    vertical:ScrollIntention;\n}\n\ninterface IScrollBounds {\n    x:number;\n    y:number;\n    width:number;\n    height:number;\n    scrollX:number;\n    scrollY:number;\n    scrollHeight:number;\n    scrollWidth:number;\n}\n\nconst enum ScrollIntention {\n    NONE = 0,\n    LEFT_OR_TOP = -1,\n    RIGHT_OR_BOTTOM = 1\n}\n\nconst enum ScrollAxis {\n    HORIZONTAL,\n    VERTICAL\n}\n\nfunction isTopLevelEl(el:HTMLElement):boolean {\n\n    return (el === document.body || el === document.documentElement);\n}\n\nfunction getElementViewportOffset(el:HTMLElement, axis:ScrollAxis) {\n    let offset:number;\n\n    if (isTopLevelEl(el)) {\n        offset = (axis === ScrollAxis.HORIZONTAL) ? el.clientLeft : el.clientTop;\n    }\n    else {\n        const bounds = el.getBoundingClientRect();\n        offset = (axis === ScrollAxis.HORIZONTAL) ? bounds.left : bounds.top;\n    }\n\n    return offset;\n}\n\nfunction getElementViewportSize(el:HTMLElement, axis:ScrollAxis) {\n    let size:number;\n\n    if (isTopLevelEl(el)) {\n        size = (axis === ScrollAxis.HORIZONTAL) ? window.innerWidth : window.innerHeight;\n    }\n    else {\n        size = (axis === ScrollAxis.HORIZONTAL) ? el.clientWidth : el.clientHeight;\n    }\n\n    return size;\n}\n\nfunction getSetElementScroll(el:HTMLElement, axis:ScrollAxis, scroll?:number) {\n    const prop = (axis === ScrollAxis.HORIZONTAL) ? \"scrollLeft\" : \"scrollTop\";\n\n    // abstracting away compatibility issues on scroll properties of document/body\n    const isTopLevel = isTopLevelEl(el);\n\n    if (arguments.length === 2) {\n\n        if (isTopLevel) {\n            return document.body[prop] || document.documentElement[prop];\n        }\n\n        return el[prop];\n    }\n\n    if (isTopLevel) {\n        document.documentElement[prop] += scroll;\n        document.body[prop] += scroll;\n    }\n    else {\n        el[prop] += scroll;\n    }\n}\n\n//TODO check if scroll end is reached according to scroll intention? this is needed to implement scroll chaining\nfunction isScrollable(el:HTMLElement):boolean {\n    const cs = getComputedStyle(el);\n\n    if (el.scrollHeight > el.clientHeight && (cs.overflowY === \"scroll\" || cs.overflowY === \"auto\")) {\n        return true;\n    }\n\n    if (el.scrollWidth > el.clientWidth && (cs.overflowX === \"scroll\" || cs.overflowX === \"auto\")) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction findScrollableParent(el:HTMLElement):HTMLElement {\n    do {\n        if (!el) {\n            return undefined;\n        }\n        if (isScrollable(el)) {\n            return el;\n        }\n        if (el === document.documentElement) {\n            return null;\n        }\n    } while (el = <HTMLElement>el.parentNode);\n    return null;\n}\n\nfunction determineScrollIntention(currentCoordinate:number, size:number, threshold:number):ScrollIntention {\n\n    // LEFT / TOP\n    if (currentCoordinate < threshold) {\n        return ScrollIntention.LEFT_OR_TOP;\n    }\n    // RIGHT / BOTTOM\n    else if (size - currentCoordinate < threshold) {\n        return ScrollIntention.RIGHT_OR_BOTTOM;\n    }\n    // NONE\n    return ScrollIntention.NONE;\n}\n\nfunction determineDynamicVelocity(scrollIntention:ScrollIntention, currentCoordinate:number, size:number, threshold:number):number {\n\n    if (scrollIntention === ScrollIntention.LEFT_OR_TOP) {\n\n        return Math.abs(currentCoordinate - threshold);\n    }\n    else if (scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM) {\n\n        return Math.abs(size - currentCoordinate - threshold);\n    }\n\n    return 0;\n}\n\nfunction isScrollEndReached(axis:ScrollAxis, scrollIntention:ScrollIntention, scrollBounds:IScrollBounds) {\n\n    const currentScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? (scrollBounds.scrollX) : (scrollBounds.scrollY);\n\n    // wants to scroll to the right/bottom\n    if (scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM) {\n\n        const maxScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? (scrollBounds.scrollWidth - scrollBounds.width) : (scrollBounds.scrollHeight -\n            scrollBounds.height);\n\n        // is already at the right/bottom edge\n        return currentScrollOffset >= maxScrollOffset;\n    }\n    // wants to scroll to the left/top\n    else if (scrollIntention === ScrollIntention.LEFT_OR_TOP) {\n\n        // is already at left/top edge\n        return (currentScrollOffset <= 0);\n    }\n    // no scroll\n    return true;\n}\n\n//</editor-fold>\n\nlet _options:ScrollOptions = {\n    threshold: 75,\n    // simplified cubic-ease-in function\n    velocityFn: function (velocity:number, threshold:number) {\n        const multiplier = velocity / threshold;\n        const easeInCubic = multiplier * multiplier * multiplier;\n        return easeInCubic * threshold;\n    }\n};\n\nlet _scrollIntentions:ScrollIntentions = {\n    horizontal: ScrollIntention.NONE,\n    vertical: ScrollIntention.NONE\n};\n\nlet _dynamicVelocity:Point = {\n    x: 0,\n    y: 0\n};\n\nlet _scrollAnimationFrameId:any;\nlet _currentCoordinates:Point;\nlet _hoveredElement:HTMLElement;\nlet _scrollableParent:HTMLElement;\nlet _translateDragImageFn:(offsetX:number, offsetY:number) => void;\n\n/**\n * core handler function\n */\nfunction handleDragImageTranslateOverride(event:TouchEvent,\n                                          currentCoordinates:Point,\n                                          hoveredElement:HTMLElement,\n                                          translateDragImageFn:(scrollDiffX:number, scrollDiffY:number) => void):void {\n\n    _currentCoordinates = currentCoordinates;\n    _translateDragImageFn = translateDragImageFn;\n\n    // update parent if hovered element changed\n    if (_hoveredElement !== hoveredElement) {\n\n        _hoveredElement = hoveredElement;\n        _scrollableParent = findScrollableParent(_hoveredElement);\n    }\n\n    // update scroll intention and check if we should scroll at all\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    const performScrollAnimation = updateScrollIntentions(_currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity);\n\n    // no animation in progress but scroll is intended\n    if (performScrollAnimation) {\n\n        // setup scroll animation frame\n        scheduleScrollAnimation();\n    }\n    else if (!!_scrollAnimationFrameId) {\n\n        window.cancelAnimationFrame(_scrollAnimationFrameId);\n        _scrollAnimationFrameId = null;\n    }\n}\n\n//<editor-fold desc=\"programmatic scroll animation frame handler\">\n\nfunction scheduleScrollAnimation() {\n\n    // prevent scheduling when already scheduled\n    if (!!_scrollAnimationFrameId) {\n\n        return;\n    }\n\n    _scrollAnimationFrameId = window.requestAnimationFrame(scrollAnimation);\n}\n\nfunction scrollAnimation() {\n\n    let scrollDiffX = 0,\n        scrollDiffY = 0,\n        isTopLevel = isTopLevelEl(_scrollableParent);\n\n    if (_scrollIntentions.horizontal !== ScrollIntention.NONE) {\n\n        scrollDiffX = Math.round(_options.velocityFn(_dynamicVelocity.x, _options.threshold) * _scrollIntentions.horizontal);\n        getSetElementScroll(_scrollableParent, ScrollAxis.HORIZONTAL, scrollDiffX);\n    }\n\n    if (_scrollIntentions.vertical !== ScrollIntention.NONE) {\n\n        scrollDiffY = Math.round(_options.velocityFn(_dynamicVelocity.y, _options.threshold) * _scrollIntentions.vertical);\n        getSetElementScroll(_scrollableParent, ScrollAxis.VERTICAL, scrollDiffY);\n    }\n\n    if (isTopLevel) {\n        // on top level element scrolling we need to translate the drag image as much as we scroll\n        _translateDragImageFn(scrollDiffX, scrollDiffY);\n    }\n    else {\n        // just scroll the container and update the drag image position without offset\n        _translateDragImageFn(0, 0);\n    }\n\n    // reset to make sure we can re-schedule scroll animation\n    _scrollAnimationFrameId = null;\n\n    // check if we should continue scrolling\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    if (updateScrollIntentions(_currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity)) {\n\n        // re-schedule animation frame callback\n        scheduleScrollAnimation();\n    }\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"scroll checks\">\n\nfunction updateScrollIntentions(currentCoordinates:Point,\n                                scrollableParent:HTMLElement,\n                                threshold:number,\n                                scrollIntentions:ScrollIntentions,\n                                dynamicVelocity:Point):boolean {\n\n    if (!currentCoordinates || !scrollableParent) {\n\n        // when coordinates become undefined drag operation stopped. stop scrolling also.\n        return false;\n    }\n\n    const scrollableParentBounds:IScrollBounds = {\n        x: getElementViewportOffset(scrollableParent, ScrollAxis.HORIZONTAL),\n        y: getElementViewportOffset(scrollableParent, ScrollAxis.VERTICAL),\n        width: getElementViewportSize(scrollableParent, ScrollAxis.HORIZONTAL),\n        height: getElementViewportSize(scrollableParent, ScrollAxis.VERTICAL),\n        scrollX: getSetElementScroll(scrollableParent, ScrollAxis.HORIZONTAL),\n        scrollY: getSetElementScroll(scrollableParent, ScrollAxis.VERTICAL),\n        scrollWidth: scrollableParent.scrollWidth,\n        scrollHeight: scrollableParent.scrollHeight\n    };\n\n    const currentCoordinatesOffset = {\n        x: currentCoordinates.x - scrollableParentBounds.x,\n        y: currentCoordinates.y - scrollableParentBounds.y\n    };\n\n    scrollIntentions.horizontal = determineScrollIntention(currentCoordinatesOffset.x, scrollableParentBounds.width, threshold);\n    scrollIntentions.vertical = determineScrollIntention(currentCoordinatesOffset.y, scrollableParentBounds.height, threshold);\n\n    if (scrollIntentions.horizontal && isScrollEndReached(ScrollAxis.HORIZONTAL, scrollIntentions.horizontal, scrollableParentBounds)) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.horizontal = ScrollIntention.NONE;\n    }\n    else if (scrollIntentions.horizontal) {\n\n        dynamicVelocity.x = determineDynamicVelocity(scrollIntentions.horizontal, currentCoordinatesOffset.x, scrollableParentBounds.width, threshold);\n    }\n\n    if (scrollIntentions.vertical && isScrollEndReached(ScrollAxis.VERTICAL, scrollIntentions.vertical, scrollableParentBounds)) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.vertical = ScrollIntention.NONE;\n    }\n    else if (scrollIntentions.vertical) {\n\n        dynamicVelocity.y = determineDynamicVelocity(scrollIntentions.vertical, currentCoordinatesOffset.y, scrollableParentBounds.height, threshold);\n    }\n\n    return !!(scrollIntentions.horizontal || scrollIntentions.vertical);\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"public api\">\n\nexport interface ScrollOptions {\n    // threshold in px. when distance between scrollable element edge and touch position is smaller start programmatic scroll.\n    // defaults to 75px\n    threshold?:number;\n    // function to customize the scroll velocity\n    // velocity param: distance to scrollable element edge\n    // threshold: the threshold used to determine when scrolling should start\n    // defaults to cubic-ease-in.\n    velocityFn:(velocity:number, threshold:number) => number;\n}\n\nexport const scrollBehaviourDragImageTranslateOverride:DragImageTranslateOverrideFn = handleDragImageTranslateOverride;\n\n//</editor-fold>\n"]}